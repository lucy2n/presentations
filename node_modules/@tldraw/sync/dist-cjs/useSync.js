"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useSync_exports = {};
__export(useSync_exports, {
  useSync: () => useSync
});
module.exports = __toCommonJS(useSync_exports);
var import_state = require("@tldraw/state");
var import_state_react = require("@tldraw/state-react");
var import_sync_core = require("@tldraw/sync-core");
var import_react = require("react");
var import_tldraw = require("tldraw");
const MULTIPLAYER_EVENT_NAME = "multiplayer.client";
function useSync(opts) {
  const [state, setState] = (0, import_tldraw.useRefState)(null);
  const {
    uri,
    roomId = "default",
    assets,
    onMount,
    trackAnalyticsEvent: track,
    userInfo,
    ...schemaOpts
  } = opts;
  const __never__ = 0;
  const schema = (0, import_tldraw.useTLSchemaFromUtils)(schemaOpts);
  const prefs = (0, import_tldraw.useShallowObjectIdentity)(userInfo);
  const userAtom = (0, import_state_react.useAtom)("userAtom", prefs);
  (0, import_react.useEffect)(() => {
    userAtom.set(prefs);
  }, [prefs, userAtom]);
  (0, import_react.useEffect)(() => {
    const storeId = (0, import_tldraw.uniqueId)();
    const userPreferences = (0, import_tldraw.computed)(
      "userPreferences",
      () => {
        const userStuff = userAtom.get();
        const user = ((0, import_state.isSignal)(userStuff) ? userStuff.get() : userStuff) ?? (0, import_tldraw.getUserPreferences)();
        return {
          id: user.id,
          color: user.color ?? import_tldraw.defaultUserPreferences.color,
          name: user.name ?? import_tldraw.defaultUserPreferences.name
        };
      }
    );
    const socket = new import_sync_core.ClientWebSocketAdapter(async () => {
      const uriString = typeof uri === "string" ? uri : await uri();
      const withParams = new URL(uriString);
      if (withParams.searchParams.has("sessionId")) {
        throw new Error(
          'useSync. "sessionId" is a reserved query param name. Please use a different name'
        );
      }
      if (withParams.searchParams.has("storeId")) {
        throw new Error(
          'useSync. "storeId" is a reserved query param name. Please use a different name'
        );
      }
      withParams.searchParams.set("sessionId", import_tldraw.TAB_ID);
      withParams.searchParams.set("storeId", storeId);
      return withParams.toString();
    });
    socket.onStatusChange((val, closeCode) => {
      if (val === "error" && closeCode === import_sync_core.TLCloseEventCode.NOT_FOUND) {
        track?.(MULTIPLAYER_EVENT_NAME, { name: "room-not-found", roomId });
        setState({ error: new import_sync_core.TLRemoteSyncError(import_sync_core.TLIncompatibilityReason.RoomNotFound) });
        client.close();
        socket.close();
        return;
      }
    });
    let didCancel = false;
    const collaborationStatusSignal = (0, import_tldraw.computed)(
      "collaboration status",
      () => socket.connectionStatus === "error" ? "offline" : socket.connectionStatus
    );
    const store = (0, import_tldraw.createTLStore)({
      id: storeId,
      schema,
      assets,
      onMount,
      collaboration: {
        status: collaborationStatusSignal
      }
    });
    const client = new import_sync_core.TLSyncClient({
      store,
      socket,
      didCancel: () => didCancel,
      onLoad(client2) {
        track?.(MULTIPLAYER_EVENT_NAME, { name: "load", roomId });
        setState({ readyClient: client2 });
      },
      onLoadError(err) {
        track?.(MULTIPLAYER_EVENT_NAME, { name: "load-error", roomId });
        console.error(err);
        setState({ error: err });
      },
      onSyncError(reason) {
        track?.(MULTIPLAYER_EVENT_NAME, { name: "sync-error", roomId, reason });
        setState({ error: new import_sync_core.TLRemoteSyncError(reason) });
      },
      onAfterConnect() {
        store.ensureStoreIsUsable();
      },
      presence: (0, import_tldraw.createPresenceStateDerivation)(userPreferences)(store)
    });
    return () => {
      didCancel = true;
      client.close();
      socket.close();
      setState(null);
    };
  }, [assets, onMount, userAtom, roomId, schema, setState, track, uri]);
  return (0, import_tldraw.useValue)(
    "remote synced store",
    () => {
      if (!state) return { status: "loading" };
      if (state.error) return { status: "error", error: state.error };
      if (!state.readyClient) return { status: "loading" };
      const connectionStatus = state.readyClient.socket.connectionStatus;
      return {
        status: "synced-remote",
        connectionStatus: connectionStatus === "error" ? "offline" : connectionStatus,
        store: state.readyClient.store
      };
    },
    [state]
  );
}
//# sourceMappingURL=useSync.js.map
